{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/shivam/TheMovie/src/app/api/ai-recommend/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport recommendationsData from '@/data/recommendations.json';\n\n// Type assertion for the JSON data\nconst recommendations = recommendationsData as Record<string, number[]>;\n\nexport async function GET(request: Request) {\n    const { searchParams } = new URL(request.url);\n\n    // Support both single 'movieId' and batch 'movieIds'\n    const movieIdParam = searchParams.get('movieId');\n    const movieIdsParam = searchParams.get('movieIds');\n\n    const movieIds = movieIdsParam ? movieIdsParam.split(',') : (movieIdParam ? [movieIdParam] : []);\n\n    if (movieIds.length === 0) {\n        return NextResponse.json({ error: 'Movie ID(s) required' }, { status: 400 });\n    }\n\n    try {\n        const scores: Record<number, number> = {};\n\n        // Process all input movies\n        for (const id of movieIds) {\n            const recs = recommendations[id];\n            if (recs) {\n                // Add scores: +1 for each time a movie is recommended\n                // Earlier items in the list get slightly higher weight (optional optimization)\n                recs.forEach((recId, index) => {\n                    if (!scores[recId]) scores[recId] = 0;\n                    scores[recId] += (1 + (1 / (index + 1))); // Simple weighting: 1 for existence + positional boost\n                });\n            }\n        }\n\n        // Convert to array and sort by score\n        const sortedRecs = Object.entries(scores)\n            .sort(([, scoreA], [, scoreB]) => scoreB - scoreA) // Descending\n            .map(([id]) => parseInt(id))\n            // Filter out input movies (don't recommend what they just watched)\n            .filter(id => !movieIds.includes(id.toString()));\n\n        if (sortedRecs.length === 0) {\n            return NextResponse.json({ recommendations: [] });\n        }\n\n        // Return top 20\n        return NextResponse.json({ recommendations: sortedRecs.slice(0, 20) });\n\n    } catch (error) {\n        console.error('AI Recommendation Error:', error);\n        return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEA,mCAAmC;AACnC,MAAM,kBAAkB,iHAAmB;AAEpC,eAAe,IAAI,OAAgB;IACtC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAE5C,qDAAqD;IACrD,MAAM,eAAe,aAAa,GAAG,CAAC;IACtC,MAAM,gBAAgB,aAAa,GAAG,CAAC;IAEvC,MAAM,WAAW,gBAAgB,cAAc,KAAK,CAAC,OAAQ,eAAe;QAAC;KAAa,GAAG,EAAE;IAE/F,IAAI,SAAS,MAAM,KAAK,GAAG;QACvB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAuB,GAAG;YAAE,QAAQ;QAAI;IAC9E;IAEA,IAAI;QACA,MAAM,SAAiC,CAAC;QAExC,2BAA2B;QAC3B,KAAK,MAAM,MAAM,SAAU;YACvB,MAAM,OAAO,eAAe,CAAC,GAAG;YAChC,IAAI,MAAM;gBACN,sDAAsD;gBACtD,+EAA+E;gBAC/E,KAAK,OAAO,CAAC,CAAC,OAAO;oBACjB,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,GAAG;oBACpC,MAAM,CAAC,MAAM,IAAK,IAAK,IAAI,CAAC,QAAQ,CAAC,GAAK,uDAAuD;gBACrG;YACJ;QACJ;QAEA,qCAAqC;QACrC,MAAM,aAAa,OAAO,OAAO,CAAC,QAC7B,IAAI,CAAC,CAAC,GAAG,OAAO,EAAE,GAAG,OAAO,GAAK,SAAS,QAAQ,aAAa;SAC/D,GAAG,CAAC,CAAC,CAAC,GAAG,GAAK,SAAS,IACxB,mEAAmE;SAClE,MAAM,CAAC,CAAA,KAAM,CAAC,SAAS,QAAQ,CAAC,GAAG,QAAQ;QAEhD,IAAI,WAAW,MAAM,KAAK,GAAG;YACzB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,iBAAiB,EAAE;YAAC;QACnD;QAEA,gBAAgB;QAChB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,iBAAiB,WAAW,KAAK,CAAC,GAAG;QAAI;IAExE,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACJ"}}]
}